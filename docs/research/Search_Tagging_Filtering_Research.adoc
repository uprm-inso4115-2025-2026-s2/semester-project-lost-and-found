= Search, Tagging and Filtering Research

Adriel Bracero Gonzalez

== Executive Summary
This brief recommends a practical search and discovery design for the Lost and Found application. It covers a search-ready metadata schema, a controlled tagging taxonomy with fallback free-tags, faceted filtering strategies, ranking signals (including geo-awareness and recency), retrieval approaches (full-text, faceted, and vector/image similarity), UI patterns, API sketches, evaluation plan, and small Python examples to prototype components. The recommendations balance development cost, user success rate, and privacy/safety considerations.

== Scope and Objectives
*Goal:* Design an approach so owners can find lost items quickly and reliably across text, tags, and images, and so staff can moderate/curate item metadata.
*Audience:* Frontend and backend developers, UX developers, and managers.

== Key Definitions
- *Full-text search* — text-based retrieval using tokenization, stemming, and inverted indexes.
- *Faceted search* — presenting filters (facets) derived from metadata so users narrow results quickly.
- *Vector search / image similarity* — using numeric embeddings to find visually similar images.
- *Tag taxonomy* — a controlled vocabulary for consistent categorization, plus rules for free-tag fallback.

== Core Requirements (high level)
- Fast keyword lookup (title, description, tags).
- Faceted filters (category, date range, location radius, color, brand).
- Geo-aware ranking (proximity boost from the searcher's location).
- Optional image-based retrieval for photos of the lost object.
- Lightweight moderation for tags and content.
- Privacy-first defaults (avoid exposing finder contact info).

== Recommended Metadata Schema
A compact schema that supports both search and UI filters. Fields shown with recommended types.

- item_id: string (UUID)
- title: string
- description: text (full-text searchable)
- category: enum (electronics, keys, wallet, clothing, id)
- tags: array[string] (controlled + free)
- photos: array[object] (url, hash, embedding_id?)
- found_at_time: datetime
- found_at_location: {lat:float, lon:float}
- stored_location_id: string
- status: enum (reported, cataloged, stored, claimed, disposed)
- reporter_id: string
- reported_at: datetime
- color_hint: string (simple color keywords)
- brand_hint: string
- sensitive_flag: boolean
- image_embedding_id: string (optional; for vector search)

== Tag Taxonomy and Tagging Rules
*Why a taxonomy?* Controlled tags improve precision of filters and aggregations; free tags capture unexpected details.

Proposal:
- Start with a small controlled vocabulary (20–30 tags) under broad categories: Electronics (phone, laptop), Accessories (keys, wallet, glasses), Apparel (jacket, shoe), Documents (ID, passport), Bags (backpack, purse).
- Allow users to add free-tags; queue free-tags for moderation before promoting them to controlled tags.
- Normalize tags (lowercase, remove punctuation), and provide tag suggestions at input time (autocomplete) to reduce duplicates.
- Use synonyms mapping (examples: "iPhone" -> "phone", "wallet" -> "billfold" mapping) to improve recall.

== Retrieval Approaches (comparison)
. Full-text + faceted filters (recommended baseline)
- Pros: fast to implement with Elasticsearch or database + trigram index; supports faceting via aggregations. Good for keywords and tags.
- Cons: limited for images or fuzzy visual matches.
. Vector / image similarity (optional advanced)
- Pros: enables "search by photo" using embeddings (FAISS, Annoy). Useful when owner only has a photo.
- Cons: higher infra cost and needs embedding pipeline.
. Hybrid (recommended practical path)
- Implement full-text + faceted search first; add vector search later for image similarity.
- Use a coarse-to-fine approach: candidate retrieval via keyword/facets, rerank with embedding similarity when available.

== Ranking Signals and Heuristics
Proposed signal list (combined into a scoring function during search result sorting):
1. Exact tag/category match (high weight)
2. Location proximity (distance-based decay function)
3. Timestamp recency (more recent finds first)
4. Text relevance (a score)
5. Image similarity score (if owner-provided photo used)
6. Reporter trust score (verified staff reports boost)
7. Popularity / engagement (replies or flags) - lower weight

Example ranking formula (conceptual):
score = 3*(tag_match) + 2*(proximity_score) + 1.5*(recency_score) + 1*(text_score) + 2*(image_score_if_any)

== Filter and UI Patterns
- Left-side facets: category, date range, storage status, color, brand.
- Map / radius filter: show results in a list + interactive map; allow radius slider.
- Quick filters: "Items found near me", "Recently added", "High-priority (sensitive)".
- Result card design: prominent photo, title, found_at_location (text), found_at_time (relative), status tag, "Claim" CTA.
- Empty-state guidance: show tips on phrasing queries and how to use filters.



== Small Python Examples
[source,python]
----
# Simple proximity score (Haversine, returns km)
import math

def haversine(lat1, lon1, lat2, lon2):
    R = 6371.0
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlambda = math.radians(lon2 - lon1)
    a = math.sin(dphi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(dlambda/2)**2
    return 2*R*math.asin(math.sqrt(a))

def proximity_score(km, radius_km=5):
    # simple decay: 1.0 at distance 0, 0 at distance >= radius_km
    return max(0.0, 1 - (km / radius_km))

----

[source,python]
----
# Very small BM25-like weight combining text_score and proximity
def combined_score(text_score, km):
    return 1.0*text_score + 2.0*proximity_score(km, radius_km=10)
----

== Diagrams (flow)
Below is a small diagram that shows a hybrid retrieval flow.

image::search_flow.png[Hybrid retrieval flow, width=800, align="center"]


== Moderation and Safety Notes
- Moderate tags and photos to prevent scams (example: deliberately vague posts used to phish owners). Allow staff to flag suspicious reports.
- Avoid showing finder contact details publicly. Use mediated communication or one-time verification tokens during claims.
- Rate-limit sensitive endpoints (claim initiation) and log attempts for audit.
- Provide an easy "report" button for suspicious activity and an admin dashboard for flagged items.

== Security and Privacy Considerations
- Store image embeddings separately from raw PII-linked records and use access controls.
- Prefer ephemeral tokens for claim verification (example: 6-digit token sent to reporter's email or phone), and do not include tokens in URLs.
- Mask precise finder locations in public responses; show approximate location text instead (example: "Main Library — 2nd floor locker area").

== References
- "Faceted Search: An Overview." Algolia Blog, 15 July 2024, https://www.algolia.com/blog/ux/faceted-search-an-overview. 
- Johnson, Jeff, Matthijs Douze, and Hervé Jégou. "Billion-scale similarity search with GPUs." arXiv, 28 Feb. 2017, https://arxiv.org/abs/1702.08734.
- "Faceted Search." Wikipedia, https://en.wikipedia.org/wiki/Faceted_search.
- "Search: Visible and Simple." Nielsen Norman Group, 12 May 2001, https://www.nngroup.com/articles/search-visible-and-simple/. 
- "Faceted Search" (Elasticsearch Labs), Elastic, https://www.elastic.co/search-labs/tutorials/search-tutorial/full-text-search/facets

